use std::path::Path;
use std::ffi::CString;
use std::os::raw::c_char;

use spritec::loaders;
use vek::Rgba;

use crate::wasm::io::read_file_buf;
use crate::wasm::str::ptr_to_str;
use crate::renderer::{Renderer, ConfigureRenderer};

/// Create a new renderer to draw the given file with the given size.
///
/// IMPORTANT NOTE: If the allocator re-allocates the web assembly memory, this pointer will
/// become *INVALIDATED*.
#[no_mangle]
extern fn renderer_new(path: *mut c_char, width: usize, height: usize, scale: usize) -> *mut Renderer {
    let path = unsafe { ptr_to_str(path) };
    let path = Path::new(&path);
    let mut buf: &[u8] = &read_file_buf(path);
    let model = loaders::obj::from_reader(&mut buf, |mtl| {
        let mtl = if let Some(parent) = path.parent() {
            parent.join(mtl)
        } else { mtl.to_path_buf() };
        let buf = read_file_buf(mtl);
        tobj::load_mtl_buf(&mut &*buf)
    }).expect("Unable to read file");

    let renderer = Box::new(Renderer::new(model, width, height, scale));
    // Ownership of this value is given to the caller. It is *not* freed at the end of this function.
    Box::into_raw(renderer)
}

/// Delete a previously created renderer
#[no_mangle]
unsafe extern fn renderer_delete(r_ptr: *mut Renderer) {
    // Loads the value and then immediately drops it
    let _ = Box::from_raw(r_ptr);
}

/// Returns a pointer to the image data generated by the renderer (compatible with Uint8ClampedArray)
#[no_mangle]
unsafe extern fn image_data(r_ptr: *mut Renderer) -> *const u8 {
    let renderer = Renderer::from_raw_leak(r_ptr);
    renderer.image_data().as_ptr()
}

/// Returns a JSON string of the valid configuration constants and their u8 values
#[no_mangle]
unsafe extern fn renderer_config_options() -> *const c_char {
    // Since we're building the string statically ourselves, it should never be invalid
    CString::new(ConfigureRenderer::options()).unwrap().into_raw()
}

/// Set a configuration option on the renderer that takes a usize
#[no_mangle]
unsafe extern fn renderer_config_usize(r_ptr: *mut Renderer, opt: u8, arg: usize) {
    let renderer = Renderer::from_raw_leak(r_ptr);
    renderer.config(ConfigureRenderer::from_usize(opt.into(), arg));
}

/// Set a configuration option on the renderer that takes a f32
#[no_mangle]
unsafe extern fn renderer_config_f32(r_ptr: *mut Renderer, opt: u8, arg: f32) {
    let renderer = Renderer::from_raw_leak(r_ptr);
    renderer.config(ConfigureRenderer::from_f32(opt.into(), arg));
}

/// Set a configuration option on the renderer that takes a Rgba<f32>
#[no_mangle]
unsafe extern fn renderer_config_rgba(r_ptr: *mut Renderer, opt: u8, r: f32, g: f32, b: f32, a: f32) {
    let renderer = Renderer::from_raw_leak(r_ptr);
    renderer.config(ConfigureRenderer::from_rgba(opt.into(), Rgba {r, g, b, a}));
}

/// Performs a render and returns a new pointer to the renderer in case the previous one has been
/// invalidated by any allocations. If the pointer has been changed, all pointers to data within
/// the renderer are also invalidated.
#[no_mangle]
unsafe extern fn renderer_render(r_ptr: *mut Renderer) -> *const Renderer {
    let mut renderer = Box::from_raw(r_ptr);
    renderer.render();

    Box::into_raw(renderer)
}
